# -*- coding: utf-8 -*-
"""PROYECTO_TURISMO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1At62OgOTdxM-rYDl9IvVHUD89Pj5oP50

##Se cargan las bibliotecas para poder desarrollar el analisis
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files
import seaborn as sns
import statsmodels.api as sm

"""Se debe cargar la primer base de datos al colab para luego llamarlo y poder abrirlo"""

datos = pd.read_excel("/content/compendio.xlsx")   #dataFrame
datos.head()

"""#solicito informacion general de los datos para lograr un primer vistazo de que tipo de datos se analizaran posteriormente"""

# Solicito información general de la base de datos
datos.info()

"""## como primer acercamiento a los datos solicito informacion estadistica descriptiva"""

# Estadísticas descriptivas de las tres variables cuantitativas
datos.describe()

"""## realizo el calculo independiente de prueba a tres variables solicitando su media para verificar el codigo anterior y saber la naturaleza de la variable"""

# Calculo el promedio de los gastos del turismo
datos['gastos'].mean(), datos.gastos.mean(), np.mean(datos['gastos'])

# Calculo el promedio de los gastos del turismo
datos['ingresos'].mean(), datos.ingresos.mean(), np.mean(datos['ingresos'])

# Calculo el promedio de los gastos del turismo
datos['utiliad'].mean(), datos.utiliad.mean(), np.mean(datos['utiliad'])

"""## Creo una variable nueva llamada cobertura  mediante la division de los ingresos al estado por concepto de turimo y los gatos que incurre el estado en el sector turismo. lo cual evidenciaria por cada unidad monetaria ingresada al pais por concepto de turimo cuantas unidades monetarias se gastan para sustentar este mismo sector desde una perspectiva administrativa"""

# Calculo una variable secundaria a partir de variables originarias
#por cada ingreso en el pais cuanto se destina para cubrir el gasto? todo en materia de turismo
datos['cobertura'] = datos['ingresos']/datos['gastos']
datos.head()

"""##compruebo que mi nueva variable creada  llamada cobertura llamando de nuevo mi data y verificando su aparicion"""

datos

# @title gastos vs entrada de personas

from matplotlib import pyplot as plt
datos.plot(kind='scatter', x='gastos', y='entrada de personas', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

"""## En la siguiente grafico se evidencia el comportamiento de la utilidad  resultante de restar los ingresos  y los gastos en un alinea temporal desde el año 2005 hasta el año 2020.

### La utilidad tiene un comportamiento creciente a lo largo del tiempo con una caida en el 2014 lo cual podria atribuirse a una sequi fuerte que hubo en el pais y afecto la utilidad en terminos de turimo para el gobierno nacional y finalmente en el año 2020 tiene una caida contundente debido a la pandemia.
"""

# @title año vs utiliad

from matplotlib import pyplot as plt
import seaborn as sns
def _plot_series(series, series_name, series_index=0):
  palette = list(sns.palettes.mpl_palette('Dark2'))
  xs = series['año']
  ys = series['utiliad']

  plt.plot(xs, ys, label=series_name, color=palette[series_index % len(palette)])

fig, ax = plt.subplots(figsize=(10, 5.2), layout='constrained')
df_sorted = datos.sort_values('año', ascending=True)
_plot_series(df_sorted, '')
sns.despine(fig=fig, ax=ax)
plt.xlabel('año')
_ = plt.ylabel('utiliad')

"""## los ingresos por turismo en el pais  respecto a la entrada de extranjeros al pais muestra una linea creciente, a medida que el ingreso de personas al pais  de naturaleza extranjeros, aumenta tambien los ingresos por concepto de turimo."""

# @title ingresos vs entradad e personas

from matplotlib import pyplot as plt
import seaborn as sns
def _plot_series(series, series_name, series_index=0):
  palette = list(sns.palettes.mpl_palette('Dark2'))
  xs = series['ingresos']
  ys = series['entrada de personas']

  plt.plot(xs, ys, label=series_name, color=palette[series_index % len(palette)])

fig, ax = plt.subplots(figsize=(10, 5.2), layout='constrained')
df_sorted = datos.sort_values('ingresos', ascending=True)
_plot_series(df_sorted, '')
sns.despine(fig=fig, ax=ax)
plt.xlabel('ingresos')
_ = plt.ylabel('entrada de personas')

"""##los ingresos por turismo en el pais respecto a la salida de personas del pais muestra una linea creciente, a medida que la salida de personas del pais de naturaleza extranjeros, aumenta tambien los ingresos por concepto de turimo.

### Sin embargo muestra una linea de crecimiento las contundente sin picos bajos a comparacion de la grafica anterior de entrada de extranjeros, esto podria atribuirse  a la compra de souvenirs al momento de irse del territorio ancional.
"""

# @title ingresos vs salida de personas

from matplotlib import pyplot as plt
import seaborn as sns
def _plot_series(series, series_name, series_index=0):
  palette = list(sns.palettes.mpl_palette('Dark2'))
  xs = series['ingresos']
  ys = series['salida de personas']

  plt.plot(xs, ys, label=series_name, color=palette[series_index % len(palette)])

fig, ax = plt.subplots(figsize=(10, 5.2), layout='constrained')
df_sorted = datos.sort_values('ingresos', ascending=True)
_plot_series(df_sorted, '')
sns.despine(fig=fig, ax=ax)
plt.xlabel('ingresos')
_ = plt.ylabel('salida de personas')

"""##en esta seccion analizaremos  el procesamiento y modelado de las variables para crear un analisis de varianza (Anova)

### que inicia con darle un titulo a las variables para que sea mas facil su modelamiento al momento de ejecutar el modelo OLS
"""

c1=datos['ingresos']
c2=datos['entrada de personas']
c3=datos['salida de personas']

# Preprocesado y modelado
# ==============================================================================
import statsmodels as sm
from statsmodels.api import add_constant
from statsmodels.api import OLS
from statsmodels.formula.api import ols
# Configuración warnings
# ==============================================================================
import warnings
warnings.filterwarnings('ignore')

# Analysis of Variance (ANOVA) on linear models
from statsmodels.stats.anova import anova_lm
import statsmodels.stats.anova as  smf

"""## En el modelo OLS evidenciamos inicialmente  el R ajustado que comprueba lo precios que es el modelo el cual da un 97% de ajuste, pero esto tambien es debido a la cantidad de variables que es pequeña.

### como mencionamos anteriormente la variable que mas aporta alos ingresos es la salida internacional de personas
"""

data = pd.DataFrame({'y': c1, 'x1': c2, 'x2': c3})

model = ols("y ~ x1 + x2", data).fit()

# Print the summary
print(model.summary())

print("\nRetrieving manually the parameter estimates:")
print(model._results.params)


plt.show()

corre= datos.corr()
corre

"""## el siguiente grafico muestra un mapa de calor donde los mas oscuros son los que mas se correlacionan para este caso los ingresos se ven mas corrleacionados con la salia de personas internacionalmente seguido de entrada de personas
## el gato del pais en terminos de turismo tambien se ve corrlacionada mayor mente por la salida de personasinternacionalmente
"""

sns.heatmap(corre, cmap= "YlGn");

"""# data nueva (cantidad de empleados) en terminos de ubicacion geografica  de la cantidad de empresas que se catalogan en el sector turismo alo largo del Pais y la caracterizacion de las empresas en las que trabajan."""

datos_empleos = pd.read_excel("/content/DATOS EMPLEADOS.xlsx")   #dataFrame
datos_empleos.head()

datos_empleos = datos_empleos[datos_empleos['NOMDEP'] != 'NO DETERMINADO']

# Solicito información general de la base de datos
datos_empleos.info()

"""## Dentro de la descripcion de la variable de empleados se evidencia un primer acercamiento de la media los minimos y los maximos de personas que pueden trabajar en el sector del turimo"""

# Estadísticas descriptivas de las tres variables cuantitativas
datos_empleos.describe()

"""## creo una lista donde pueda ver solamente la cantidad de empleados y en el departamento donde se encuentran"""

depto = []
peso = []
DATOS_DEP= (datos_empleos['NOMDEP']).unique().tolist()
total = len(datos_empleos['NOMDEP'])

for i in DATOS_DEP:
    depto.append(i)
    a = (len(datos_empleos[datos_empleos['NOMDEP']== i]))/total
    peso.append(a)

nuevodf = pd.DataFrame()

nuevodf['DEPTO'] = depto
nuevodf['Peso'] = peso

nuevodf

"""## en la sigueinte grafico se evidencia el peso que toman la cantidad de empleados segun su agrupacion es decir, las empresas tienen de 0 a 10 empleados en su mayoria, las empresas que emplean mas empleados con cada vez mas pocas."""

from matplotlib import pyplot as plt
import seaborn as sns
def _plot_series(series, series_name, series_index=0):
  palette = list(sns.palettes.mpl_palette('Dark2'))
  xs = series['index']
  ys = series['Peso']

  plt.plot(xs, ys, label=series_name, color=palette[series_index % len(palette)])

fig, ax = plt.subplots(figsize=(10, 5.2), layout='constrained')
df_sorted = _df_23.sort_values('index', ascending=True)
_plot_series(df_sorted, '')
sns.despine(fig=fig, ax=ax)
plt.xlabel('index')
_ = plt.ylabel('Peso')

"""## dentro de la lista que realice anteriormente deseo filtrar los departamentos que emplean mas personas y se identifican mediante un porcentaje de participacion , dentro del total de empleados en que departamento se situan mas y le asigna un peso a cada departamento respecto al total"""

nuevodf[nuevodf['Peso'] >= 0.05]

list((nuevodf['DEPTO'])[nuevodf['Peso'] >= 0.05])

list((nuevodf['DEPTO'])[nuevodf['Peso'] < 0.05])

"""## creo un dictado para que los departamentos con un peso mayor a 5% se queden con el mismo nombre y las que obtengan un peso inferior se denominen "otro" y asi agrupar los departamentos con menos relevancia."""

dic = {'BOGOTA':'BOGOTA', 'MAGDALENA':'MAGDALENA', 'ANTIOQUIA': 'ANTIOQUIA', 'BOLIVAR':'BOLIVAR' , 'VALLE DEL CAUCA':'VALLE DEL CAUCA', 'CUNDINAMARCA': 'CUNDINAMARCA', 'SANTANDER': 'SANTANDER', 'CHOCO': 'OTRO', 'SAN ANDRES Y PROVIDENCIA': 'OTRO' , 'NORTE DESANTANDER': 'OTRO','CAUCA': 'OTRO',  'META': 'OTRO','ATLANTICO': 'OTRO', 'RISARALDA': 'OTRO', 'LA GUAJIRA': 'OTRO', 'QUINDIO': 'OTRO', 'HUILA': 'OTRO', 'CESAR': 'OTRO', 'CALDAS': 'OTRO', 'NARIÑO': 'OTRO', 'BOYACA': 'OTRO', 'CHOCO': 'OTRO', 'TOLIMA': 'OTRO', 'AMAZONAS': 'OTRO', 'ARAUCA': 'OTRO', 'CORDOBA': 'OTRO', 'SUCRE': 'OTRO', 'GUAVIARE': 'OTRO', 'CAQUETA': 'OTRO', 'CASANARE': 'OTRO', 'VICHADA': 'OTRO', 'PUTUMAYO': 'OTRO',  'GUAINIA': 'OTRO', 'Cauca': 'OTRO',  'Guainia': 'OTRO', 'GUAJIRA': 'OTRO', 'VAUPES':'OTRO'}

datos_empleos['Categoria'] = (datos_empleos['NOMDEP']).map(dic)
datos_empleos.head()

"""## Creo un grafico de torat donde  veo la participacion de cada departamento"""

import matplotlib.pyplot as plt

# Realizo un gráfico de torta
categoria, counts = np.unique(datos_empleos['Categoria'], return_counts=True)
categoria, counts
fig = plt.figure(figsize=(4,4))
_ = plt.pie(counts, labels=categoria, autopct='%.1f%%')
plt.title('Diagrama de torta Categoria')

"""## Creo un grafico de barras para ver la participacion de cada departamento"""

fig = plt.figure(figsize=(15,4))
_ = plt.bar(categoria, counts)
plt.grid()
_ = plt.title('Diagrama de barras Categoria')

np.sum((datos_empleos['EMPLEADOS'])[datos_empleos['Categoria']== 'BOGOTA'])

np.sum((datos_empleos['EMPLEADOS'])[datos_empleos['Categoria']== 'ANTIOQUIA'])

np.sum((datos_empleos['EMPLEADOS'])[datos_empleos['Categoria']== 'BOLIVAR'])

np.sum((datos_empleos['EMPLEADOS'])[datos_empleos['Categoria']== 'CUNDINAMARCA'])

np.sum((datos_empleos['EMPLEADOS'])[datos_empleos['Categoria']== 'MAGDALENA'])

np.sum((datos_empleos['EMPLEADOS'])[datos_empleos['Categoria']== 'SANTANDER'])

np.sum((datos_empleos['EMPLEADOS'])[datos_empleos['Categoria']== 'VALLE DEL CAUCA'])

"""# identifico la cantidad de empleados directamente  por cada departamento debido a la lista que se creo llamada categoria"""

(datos_empleos.groupby( ['Categoria']).sum('EMPLEADOS'))

"""# en los oguientes graficos de torta y de barras excluyo los departamentos con menos empleados y agrupados con el nombre de otro y solamente grafico los departamentos que emplean mas personas en el pais por concepto de turismo"""

((datos_empleos[datos_empleos['Categoria'] != 'OTRO']).groupby( ['Categoria']).sum(['EMPLEADOS'])).plot.bar()

((datos_empleos[datos_empleos['Categoria'] != 'OTRO']).groupby( ['Categoria']).sum(['EMPLEADOS']))

# Realizo un gráfico de torta
imc_group, empleados_por_ciudad = np.unique((datos_empleos['Categoria'])[datos_empleos['Categoria'] != 'OTRO'], return_counts=True)
imc_group, empleados_por_ciudad
fig = plt.figure(figsize=(4,4))
_ = plt.pie(empleados_por_ciudad, labels=imc_group, autopct='%.1f%%')
plt.title('Diagrama de torta empleados')
